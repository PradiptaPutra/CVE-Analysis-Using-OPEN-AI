from flask import Flask, request, jsonify, render_template
import os
import requests
import pandas as pd
from openai import OpenAI
from datetime import datetime

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
app = Flask(__name__)

session_history = []
threads = []  # Store threads
saved_threads = []



@app.route('/')
def index():
    return render_template('index.html')

@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

@app.route('/library')
def library():
    return render_template('library.html', threads=saved_threads)

@app.route('/save_thread', methods=['POST'])
def save_thread():
    data = request.get_json()
    if not data or 'title' not in data or 'description' not in data:
        return jsonify({"error": "Invalid input"}), 400

    title = data['title']
    description = data['description']
    time_ago = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    thread_id = len(saved_threads)
    saved_threads.append({
        "id": thread_id,
        "title": title,
        "description": description,
        "time_ago": time_ago,
        "session_history": session_history.copy()  # Include session history
    })
    return jsonify({"message": "Thread saved successfully."})

@app.route('/thread/<int:thread_id>')
def get_thread(thread_id):
    if thread_id < 0 or thread_id >= len(saved_threads):
        return jsonify({"error": "Thread not found"}), 404
    return render_template('thread.html', thread=saved_threads[thread_id])


@app.route('/new_thread', methods=['POST'])
def new_thread():
    global session_history
    session_history = []
    return jsonify({"message": "New thread started."})

@app.route('/ask', methods=['POST'])
def ask():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()
    audience = data.get('audience', 'anyone')

    try:
        if "CVE-" in user_input:
            cve_id = user_input.split('/')[-1]
            result = fetch_cve_data(cve_id)
            if result and 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details, audience)
                    return jsonify({"response": openai_response})
                else:
                    return jsonify({"error": "Failed to extract CVE details."})
            else:
                return jsonify({"error": result['error'] if result else "No CVE found."})
        else:
            search_results = perform_web_search(user_input)
            if search_results:
                summarized_context = summarize_context(search_results)
                return jsonify({"results": search_results, "summary": summarized_context})
            else:
                return jsonify({"results": [], "summary": "No relevant information found."})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file:
        file_path = os.path.join("/tmp", file.filename)
        file.save(file_path)
        cve_ids = process_csv(file_path)
        responses = []
        for cve_id in cve_ids:
            cve_id = cve_id.upper()
            result = fetch_cve_data(cve_id)
            if 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details)
                    responses.append({cve_id: openai_response})
                else:
                    responses.append({cve_id: "Failed to extract CVE details."})
            else:
                responses.append({cve_id: result['error']})
        return jsonify({"responses": responses})
    return jsonify({"error": "File processing failed"}), 400

@app.route('/web_search', methods=['POST'])
def web_search():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()

    try:
        search_results = perform_web_search(user_input)
        if search_results:
            summarized_context = summarize_context(search_results)
            return jsonify({"results": search_results, "summary": summarized_context})
        else:
            return jsonify({"results": [], "summary": "No relevant information found."})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/follow-up', methods=['POST'])
def follow_up():
    data = request.get_json()
    if not data or 'follow_up_question' not in data:
        return jsonify({"error": "Invalid input"}), 400

    follow_up_question = data['follow_up_question']
    session_history.append({"role": "user", "content": follow_up_question})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=100
    )
    follow_up_response = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": follow_up_response})
    return jsonify({"response": follow_up_response})

def fetch_cve_data(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": f"Error fetching CVE data: {str(e)}"}

def extract_details(cve_data):
    if 'vulnerabilities' in cve_data and cve_data['vulnerabilities']:
        vuln_data = cve_data['vulnerabilities'][0]
        if 'cve' in vuln_data:
            vuln = vuln_data['cve']
            details = {
                'id': vuln['id'],
                'severity': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'description': vuln['descriptions'][0]['value'] if 'descriptions' in vuln and vuln['descriptions'] else 'N/A',
                'published_date': vuln['published'] if 'published' in vuln else 'N/A',
                'last_modified_date': vuln['lastModified'] if 'lastModified' in vuln else 'N/A',
                'cvss_score': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'vector_string': vuln['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'references': [{'url': ref.get('url'), 'tags': ref.get('tags', [])} for ref in vuln.get('references', [])],
                'cpe_configurations': extract_cpe_details(vuln['configurations']) if 'configurations' in vuln else []
            }
            return details
    return None

def extract_cpe_details(config_data):
    cpe_details = []
    if isinstance(config_data, dict) and 'nodes' in config_data:
        for node in config_data['nodes']:
            for cpe_match in node['cpeMatch']:
                cpe_details.append({
                    'vulnerable': cpe_match['vulnerable'],
                    'criteria': cpe_match['criteria']
                })
    elif isinstance(config_data, list):
        for config in config_data:
            if 'nodes' in config:
                for node in config['nodes']:
                    for cpe_match in node['cpeMatch']:
                        cpe_details.append({
                            'vulnerable': cpe_match['vulnerable'],
                            'criteria': cpe_match['criteria']
                        })
    return cpe_details

@app.route('/get_cve_details', methods=['POST'])
def get_cve_details():
    data = request.get_json()
    if not data or 'cve_id' not in data:
        return jsonify({"error": "Invalid input"}), 400

    cve_id = data['cve_id'].strip().upper()
    result = fetch_cve_data(cve_id)
    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

def get_openai_response(details, audience='anyone'):
    prompt = (
        f"Provide an in-depth analysis of the identified CVE:\n"
        f"1. CVE Identification:\n"
        f"   - CVE ID: {details['id']}\n"
        f"   - Severity: {details['severity']}\n"
        f"   - Description: {details['description']}\n"
        f"   - Published Date: {details['published_date']}\n"
        f"   - Last Modified Date: {details['last_modified_date']}\n"
        f"   - CVSS Score: {details['cvss_score']}\n"
        f"   - Vector String: {details['vector_string']}\n"
        f"   - References: {details['references']}\n\n"
    )

    if audience == 'beginner':
        prompt += (
            f"2. Impact:\n"
            f"   - Describe in simple terms how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide simple steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide basic advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    elif audience == 'advanced':
        prompt += (
            f"2. Impact:\n"
            f"   - Describe in detail how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide detailed steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide in-depth advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    else:
        prompt += (
            f"2. Impact:\n"
            f"   - Describe how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )

    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=100
    )
    message = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": message})
    return message

def process_csv(file_path):
    df = pd.read_csv(file_path)
    cve_ids = df['cve_id'].tolist()
    return cve_ids

def perform_web_search(query):
    api_key = 'e73f29dd2ef1846a27d59d5980b5209574ce41ba489b31c841248c2f4b71fa5b'
    search_url = f"https://serpapi.com/search?q={query}&api_key={api_key}"
    try:
        response = requests.get(search_url)
        response.raise_for_status()
        data = response.json()
        return data['organic_results']
    except requests.RequestException as e:
        return {"error": f"Error accessing SERP API: {str(e)}"}

def summarize_context(results):
    if not results:
        return "No relevant information found. Please refine your query."

    content = "\n\n".join([f"Title: {res['title']}\nSnippet: {res['snippet']}" for res in results if 'snippet' in res])
    prompt = f"Create a summary of the following content:\n\n{content}\n\nThe summary should be concise and include the main points from the content."
    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=100
    )
    summary = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": summary})
    return summary

if __name__ == "__main__":
    app.run(debug=True)
