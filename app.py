from flask import Flask, request, jsonify, render_template
import os
import requests
from bs4 import BeautifulSoup
from openai import OpenAI
import pandas as pd
from datetime import datetime
import time

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
app = Flask(__name__)

session_history = []

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/new_thread', methods=['POST'])
def new_thread():
    global session_history
    session_history = []
    return jsonify({"message": "New thread started."})

@app.route('/library')
def library():
    return render_template('library.html', conversation_history=session_history)

@app.route('/ask', methods=['POST'])
def ask():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()  # Ensure the CVE ID is in uppercase
    audience = data.get('audience', 'anyone')

    try:
        if "CVE-" in user_input:
            cve_id = user_input.split('/')[-1]
            result = fetch_cve_data(cve_id)
            if result and 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details, audience)
                    return jsonify({"response": openai_response})
                else:
                    return jsonify({"error": "Failed to extract CVE details."})
            else:
                return jsonify({"error": result['error'] if result else "No CVE found."})
        else:
            search_results = perform_web_search(user_input)
            if search_results:
                summarized_context = summarize_context(search_results)
                return jsonify({"results": search_results, "summary": summarized_context})
            else:
                return jsonify({"results": [], "summary": "No relevant information found."})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file:
        file_path = os.path.join("/tmp", file.filename)
        file.save(file_path)
        cve_ids = process_csv(file_path)
        responses = []
        for cve_id in cve_ids:
            cve_id = cve_id.upper()  # Ensure the CVE ID is in uppercase
            result = fetch_cve_data(cve_id)
            if 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details)
                    responses.append({cve_id: openai_response})
                else:
                    responses.append({cve_id: "Failed to extract CVE details."})
            else:
                responses.append({cve_id: result['error']})
        return jsonify({"responses": responses})

    return jsonify({"error": "File processing failed"}), 400

@app.route('/web_search', methods=['POST'])
def web_search():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()  # Ensure the CVE ID is in uppercase

    try:
        search_results = perform_web_search(user_input)
        if search_results:
            summarized_context = summarize_context(search_results)
            return jsonify({"results": search_results, "summary": summarized_context})
        else:
            return jsonify({"results": [], "summary": "No relevant information found."})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/follow-up', methods=['POST'])
def follow_up():
    data = request.get_json()
    if not data or 'follow_up_question' not in data:
        return jsonify({"error": "Invalid input"}), 400

    follow_up_question = data['follow_up_question']
    session_history.append({"role": "user", "content": follow_up_question})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=500
    )
    follow_up_response = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": follow_up_response})
    return jsonify({"response": follow_up_response})

@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

def fetch_cve_data(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    print(f"Fetching CVE data from URL: {url}")  # Debugging line
    try:
        response = requests.get(url)
        response.raise_for_status()
        print(f"Response status code: {response.status_code}")  # Debugging line
        
        # Simulate processing/loading time for JSON data
        time.sleep(2)  # Adding a 2-second delay before processing the JSON data
        
        return response.json()
    except requests.RequestException as e:
        print(f"Error fetching CVE data: {e}")  # Debugging line
        return {"error": f"Error fetching CVE data: {str(e)}"}

def search_cve_google(keyword):
    search_url = f"https://www.google.com/search?q={keyword}+site:nvd.nist.gov"
    headers = {"User-Agent": "Mozilla/5.0"}
    try:
        response = requests.get(search_url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        links = soup.find_all('a')
        cve_links = []
        for link in links:
            href = link.get('href')
            if 'nvd.nist.gov/vuln/detail' in href:
                start = href.find('https')
                end = href.find('&', start)
                cve_link = href[start:end] if end != -1 else href[start:]
                cve_links.append(cve_link)
        return cve_links
    except requests.RequestException as e:
        return {"error": f"Error searching CVE data: {str(e)}"}

def get_summary_from_link(link):
    try:
        response = requests.get(link)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        description_element = soup.find('p', {'data-testid': 'vuln-description'})
        if not description_element:
            return "Description not found on the page."

        content = description_element.text.strip()
        prompt = (
            f"Provide a summary of the following text:\n\n{content}\n\n"
            "The summary should be concise, precise, and include the main points discussed in the text."
        )
        session_history.append({"role": "user", "content": prompt})
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session_history,
            max_tokens=150
        )
        summary = response.choices[0].message.content.strip()
        session_history.append({"role": "assistant", "content": summary})
        return {"link": link, "summary": summary}
    except requests.RequestException as e:
        return f"Error fetching summary: {str(e)}"

def extract_details(cve_data):
    if 'vulnerabilities' in cve_data and cve_data['vulnerabilities']:
        vuln_data = cve_data['vulnerabilities'][0]
        if 'cve' in vuln_data:
            vuln = vuln_data['cve']
            details = {
                'id': vuln['id'],
                'severity': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'description': vuln['descriptions'][0]['value'] if 'descriptions' in vuln and vuln['descriptions'] else 'N/A',
                'published_date': vuln['published'] if 'published' in vuln else 'N/A',
                'last_modified_date': vuln['lastModified'] if 'lastModified' in vuln else 'N/A',
                'cvss_score': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'vector_string': vuln['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'references': [{'url': ref.get('url'), 'tags': ref.get('tags', [])} for ref in vuln.get('references', [])],
                'cpe_configurations': extract_cpe_details(vuln['configurations']) if 'configurations' in vuln else []
            }
            return details
    return None

def extract_cpe_details(config_data):
    cpe_details = []
    if isinstance(config_data, dict) and 'nodes' in config_data:
        for node in config_data['nodes']:
            for cpe_match in node['cpeMatch']:
                cpe_details.append({
                    'vulnerable': cpe_match['vulnerable'],
                    'criteria': cpe_match['criteria']
                })
    elif isinstance(config_data, list):
        for config in config_data:
            if 'nodes' in config:
                for node in config['nodes']:
                    for cpe_match in node['cpeMatch']:
                        cpe_details.append({
                            'vulnerable': cpe_match['vulnerable'],
                            'criteria': cpe_match['criteria']
                        })
    return cpe_details

@app.route('/get_cve_details', methods=['POST'])
def get_cve_details():
    data = request.get_json()
    if not data or 'cve_id' not in data:
        return jsonify({"error": "Invalid input"}), 400

    cve_id = data['cve_id'].strip().upper()  # Ensure the CVE ID is in uppercase
    result = fetch_cve_data(cve_id)
    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

@app.route('/get_openai_response_link', methods=['POST'])
def get_openai_response_link():
    data = request.get_json()
    link = data.get('link')
    if not link:
        return jsonify({"error": "Link not provided"}), 400

    cve_id = link.split('/')[-1].strip().upper()  # Ensure the CVE ID is in uppercase
    cve_data = fetch_cve_data(cve_id)
    if cve_data and 'error' not in cve_data:
        details = extract_details(cve_data)
        if details:
            response = get_openai_response(details)
            return jsonify({"response": response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": "Failed to fetch CVE data."})

def get_openai_response(details, audience='anyone'):
    prompt = (
        f"Provide an in-depth analysis of the identified CVE:\n"
        f"1. CVE Identification:\n"
        f"   - CVE ID: {details['id']}\n"
        f"   - Severity: {details['severity']}\n"
        f"   - Description: {details['description']}\n"
        f"   - Published Date: {details['published_date']}\n"
        f"   - Last Modified Date: {details['last_modified_date']}\n"
        f"   - CVSS Score: {details['cvss_score']}\n"
        f"   - Vector String: {details['vector_string']}\n"
        f"   - References: {details['references']}\n\n"
    )

    if audience == 'beginner':
        prompt += (
            f"2. Impact:\n"
            f"   - Describe in simple terms how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide simple steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide basic advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    elif audience == 'advanced':
        prompt += (
            f"2. Impact:\n"
            f"   - Describe in detail how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide detailed steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide in-depth advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    else:
        prompt += (
            f"2. Impact:\n"
            f"   - Describe how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. Mitigation Steps:\n"
            f"   - Provide steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. Recommendations for Organizations:\n"
            f"   - Provide advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )

    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=800
    )
    message = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": message})
    return message

def process_csv(file_path):
    df = pd.read_csv(file_path)
    cve_ids = df['cve_id'].tolist()
    return cve_ids

def get_openai_response_upload(details):
    messages = [
        {"role": "system", "content": "You are an expert on cybersecurity vulnerabilities."},
        {"role": "user", "content": f"Analyze the following information about the CVE:\n\n{details}"}
    ]
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages,
        max_tokens=800
    )
    return response

def handle_cve_ids(cve_ids):
    responses = []
    for cve_id in cve_ids:
        cve_id = cve_id.upper()  # Ensure the CVE ID is in uppercase
        result = fetch_cve_data(cve_id)
        if result and 'error' not in result:
            details = extract_details(result)
            if details:
                openai_response = get_openai_response_upload(details)
                responses.append({"cve_id": cve_id, "details": details, "response": openai_response})
            else:
                responses.append({"cve_id": cve_id, "error": "Failed to extract CVE details."})
        else:
            responses.append({"cve_id": cve_id, "error": result['error'] if result else "No CVE found."})
    return responses

@app.route('/get_latest_cves', methods=['GET'])
def get_latest_cves():
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    try:
        response = requests.get(url)
        response.raise_for_status()
        cve_data = response.json()
        cves = [
            {"id": item['cve']['id']}
            for item in cve_data['vulnerabilities'][:4]
        ]
        return jsonify({"cves": cves})
    except requests.RequestException as e:
        return jsonify({"error": f"Error fetching latest CVEs: {str(e)}"})

def perform_web_search(query):
    api_key = 'e73f29dd2ef1846a27d59d5980b5209574ce41ba489b31c841248c2f4b71fa5b'
    search_url = f"https://serpapi.com/search?q={query}&api_key={api_key}"
    try:
        response = requests.get(search_url)
        response.raise_for_status()
        data = response.json()
        return data['organic_results']
    except requests.RequestException as e:
        return {"error": f"Error accessing SERP API: {str(e)}"}

def sort_by_date(results):
    def parse_date(date_str):
        try:
            return datetime.strptime(date_str, '%b %d, %Y')
        except ValueError:
            return datetime.min

    sorted_results = sorted([r for r in results if 'publication_date' in r], key=lambda x: parse_date(x['publication_date']), reverse=True)
    return sorted_results

def summarize_context(results):
    if not results:
        return "No relevant information found. Please refine your query."

    content = "\n\n".join([f"Title: {res['title']}\nSnippet: {res['snippet']}" for res in results if 'snippet' in res])
    prompt = f"Create a summary of the following content:\n\n{content}\n\nThe summary should be concise and include the main points from the content."
    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=150
    )
    summary = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": summary})
    return summary

if __name__ == "__main__":
    app.run(debug=True)
