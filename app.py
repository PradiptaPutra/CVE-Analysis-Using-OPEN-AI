from flask import Flask, request, jsonify, render_template
import os
import requests
from bs4 import BeautifulSoup
from openai import OpenAI
import pandas as pd

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
app = Flask(__name__)

session_history = []

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/new_thread', methods=['POST'])
def new_thread():
    global session_history
    session_history = []
    return jsonify({"message": "New thread started."})

@app.route('/library')
def library():
    return render_template('library.html', conversation_history=session_history)

@app.route('/ask', methods=['POST'])
def ask():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input']
    result = None
    if "CVE-" in user_input.upper():
        cve_id = user_input.upper().split('/')[-1]
        result = fetch_cve_data(cve_id)
    else:
        cve_links = search_cve_google(user_input)
        if isinstance(cve_links, list) and cve_links:
            summaries = []
            for link in cve_links[:5]:
                summary = get_summary_from_link(link)
                summaries.append({"link": link, "summary": summary})
            return jsonify({"cve_summaries": summaries})

    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file:
        file_path = os.path.join("/tmp", file.filename)
        file.save(file_path)
        cve_ids = process_csv(file_path)
        responses = []
        for cve_id in cve_ids:
            result = fetch_cve_data(cve_id)
            if 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details)
                    responses.append({cve_id: openai_response})
                else:
                    responses.append({cve_id: "Failed to extract CVE details."})
            else:
                responses.append({cve_id: result['error']})
        return jsonify({"responses": responses})

    return jsonify({"error": "File processing failed"}), 400

@app.route('/follow-up', methods=['POST'])
def follow_up():
    data = request.get_json()
    if not data or 'follow_up_question' not in data:
        return jsonify({"error": "Invalid input"}), 400

    follow_up_question = data['follow_up_question']
    session_history.append({"role": "user", "content": follow_up_question})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=500
    )
    follow_up_response = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": follow_up_response})
    return jsonify({"response": follow_up_response})

@app.route('/dashboard')
def dashboard():
    return render_template('dashboard.html')

@app.route('/get_cve_changes', methods=['GET'])
def get_cve_changes():
    change_start_date = request.args.get('start_date', '2020-01-01T00:00:00.000Z')
    change_end_date = request.args.get('end_date', '2023-01-31T23:59:59.000Z')
    event_name = request.args.get('event_name', None)

    # Ensure the dates are properly URL encoded
    change_start_date = requests.utils.quote(change_start_date)
    change_end_date = requests.utils.quote(change_end_date)

    url = f"https://services.nvd.nist.gov/rest/json/cvehistory/2.0/?changeStartDate={change_start_date}&changeEndDate={change_end_date}"
    if event_name:
        url += f"&eventName={requests.utils.quote(event_name)}"

    try:
        response = requests.get(url)
        response.raise_for_status()
        cve_changes = response.json().get('cveChanges', [])
    except requests.RequestException as e:
        return jsonify({"error": f"Error fetching CVE change history: {str(e)}"})

    cve_details_list = []
    for change in cve_changes:
        cve_id = change.get('cveId')
        if cve_id:
            cve_data = fetch_cve_data(cve_id)
            if 'error' not in cve_data:
                details = extract_details(cve_data)
                if details:
                    cve_details_list.append(details)

    return jsonify(cve_details_list)

def fetch_cve_data(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": f"Error fetching CVE data: {str(e)}"}

def search_cve_google(keyword):
    search_url = f"https://www.google.com/search?q={keyword}+site:nvd.nist.gov"
    headers = {"User-Agent": "Mozilla/5.0"}
    try:
        response = requests.get(search_url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        links = soup.find_all('a')
        cve_links = []
        for link in links:
            href = link.get('href')
            if 'nvd.nist.gov/vuln/detail' in href:
                start = href.find('https')
                end = href.find('&', start)
                cve_link = href[start:end] if end != -1 else href[start:]
                cve_links.append(cve_link)
        return cve_links
    except requests.RequestException as e:
        return {"error": f"Error searching CVE data: {str(e)}"}

def get_summary_from_link(link):
    try:
        response = requests.get(link)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        description_element = soup.find('p', {'data-testid': 'vuln-description'})
        if not description_element:
            return "Description not found on the page."

        content = description_element.text.strip()
        prompt = (
            f"Buat ringkasan dari teks berikut:\n\n{content}\n\n"
            "Ringkasan harus singkat, tepat, dan menyertakan poin-poin utama yang dibahas dalam teks."
        )
        session_history.append({"role": "user", "content": prompt})
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session_history,
            max_tokens=150
        )
        summary = response.choices[0].message.content.strip()
        session_history.append({"role": "assistant", "content": summary})
        return summary
    except requests.RequestException as e:
        return f"Error fetching summary: {str(e)}"

def extract_details(cve_data):
    if 'vulnerabilities' in cve_data and cve_data['vulnerabilities']:
        vuln_data = cve_data['vulnerabilities'][0]
        if 'cve' in vuln_data:
            vuln = vuln_data['cve']
            details = {
                'id': vuln['id'],
                'severity': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'description': vuln['descriptions'][0]['value'] if 'descriptions' in vuln and vuln['descriptions'] else 'N/A',
                'published_date': vuln['published'] if 'published' in vuln else 'N/A',
                'last_modified_date': vuln['lastModified'] if 'lastModified' in vuln else 'N/A',
                'cvss_score': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'vector_string': vuln['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'references': [{'url': ref.get('url'), 'tags': ref.get('tags', [])} for ref in vuln.get('references', [])],
                'cpe_configurations': extract_cpe_details(vuln['configurations']) if 'configurations' in vuln else []
            }
            return details
    return None

def extract_cpe_details(config_data):
    cpe_details = []
    if isinstance(config_data, dict) and 'nodes' in config_data:
        for node in config_data['nodes']:
            for cpe_match in node['cpeMatch']:
                cpe_details.append({
                    'vulnerable': cpe_match['vulnerable'],
                    'criteria': cpe_match['criteria']
                })
    elif isinstance(config_data, list):
        for config in config_data:
            if 'nodes' in config:
                for node in config['nodes']:
                    for cpe_match in node['cpeMatch']:
                        cpe_details.append({
                            'vulnerable': cpe_match['vulnerable'],
                            'criteria': cpe_match['criteria']
                        })
    return cpe_details

@app.route('/get_cve_details', methods=['POST'])
def get_cve_details():
    data = request.get_json()
    if not data or 'cve_id' not in data:
        return jsonify({"error": "Invalid input"}), 400

    cve_id = data['cve_id']
    result = fetch_cve_data(cve_id)
    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

def get_openai_response(details):
    prompt = (
        f"Analisis mendalam mengenai CVE yang diidentifikasi:\n"
        f"1. Identifikasi CVE:\n"
        f"   - CVE ID: {details['id']}\n"
        f"   - Tingkat Keparahan: {details['severity']}\n"
        f"   - Deskripsi: {details['description']}\n"
        f"   - Tanggal Publikasi: {details['published_date']}\n"
        f"   - Tanggal Modifikasi Terakhir: {details['last_modified_date']}\n"
        f"   - Skor CVSS: {details['cvss_score']}\n"
        f"   - String Vektor: {details['vector_string']}\n"
        f"   - Referensi: {details['references']}\n\n"
        f"2. Dampak:\n"
        f"   - Jelaskan secara rinci bagaimana CVE ini dapat mempengaruhi sistem yang rentan. Termasuk potensi kerusakan pada sistem, data, dan operasional.\n\n"
        f"3. Langkah-Langkah Mitigasi:\n"
        f"   - Berikan langkah-langkah spesifik yang dapat diambil untuk mengurangi risiko yang terkait dengan CVE ini. Sertakan rekomendasi tentang pembaruan perangkat lunak, konfigurasi sistem, dan praktik terbaik.\n\n"
        f"4. Rekomendasi untuk Organisasi:\n"
        f"   - Saran terbaik untuk organisasi dalam menangani kerentanan ini. Termasuk kebijakan keamanan, pelatihan karyawan, dan strategi pemantauan.\n\n"
    )
    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=800
    )
    message = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": message})
    return message

def process_csv(file_path):
    df = pd.read_csv(file_path)
    cve_ids = df['cve_id'].tolist()
    return cve_ids

def get_openai_response_upload(details):
    messages = [
        {"role": "system", "content": "You are an expert on cybersecurity vulnerabilities."},
        {"role": "user", "content": f"Analisa informasi berikut tentang CVE:\n\n{details}"}
    ]
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=messages,
        max_tokens=800
    )
    return (response)

def handle_cve_ids(cve_ids):
    responses = []
    for cve_id in cve_ids:
        result = fetch_cve_data(cve_id)
        if result and 'error' not in result:
            details = extract_details(result)
            if details:
                openai_response = get_openai_response_upload(details)
                responses.append({"cve_id": cve_id, "details": details, "response": openai_response})
            else:
                responses.append({"cve_id": cve_id, "error": "Failed to extract CVE details."})
        else:
            responses.append({"cve_id": cve_id, "error": result['error'] if result else "No CVE found."})
    return responses

@app.route('/get_latest_cves', methods=['GET'])
def get_latest_cves():
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    try:
        response = requests.get(url)
        response.raise_for_status()
        cve_data = response.json()
        cves = [
            {"id": item['cve']['id']}
            for item in cve_data['vulnerabilities'][:4]
        ]
        return jsonify({"cves": cves})
    except requests.RequestException as e:
        return jsonify({"error": f"Error fetching latest CVEs: {str(e)}"})



if __name__ == "__main__":
    app.run(debug=True)
