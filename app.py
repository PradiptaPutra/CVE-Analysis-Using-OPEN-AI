from flask import Flask, request, jsonify, render_template, redirect, url_for, session
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, logout_user, current_user, login_required
from werkzeug.security import generate_password_hash, check_password_hash
import os
import requests
import pandas as pd
from openai import OpenAI
from datetime import datetime
import re
import logging
from flask import g


# Configure logging
logging.basicConfig(level=logging.INFO)

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
db = SQLAlchemy(app)
login_manager = LoginManager(app)
login_manager.login_view = 'login'

session_history = []
threads = []  # Store threads
saved_threads = []

class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(150), nullable=False)
    threads = db.relationship('Thread', backref='author', lazy=True)

class Thread(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.String(500), nullable=False)
    time_ago = db.Column(db.String(100), nullable=False)
    session_history = db.Column(db.Text, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

class CVEEntry(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    cve_id = db.Column(db.String(100), unique=True, nullable=False)
    severity = db.Column(db.String(50), nullable=False)
    description = db.Column(db.Text, nullable=False)
    published_date = db.Column(db.String(50), nullable=False)
    last_modified_date = db.Column(db.String(50), nullable=False)
    cvss_score = db.Column(db.Float, nullable=False)

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

@app.before_request
def before_request():
    g.session_history = []

@app.route('/')
def home():
    if 'user_id' in session:
        return redirect(url_for('index'))
    return redirect(url_for('login'))

@app.route('/index')
@login_required
def index():
    return render_template('index.html')

@app.route('/dashboard')
@login_required
def dashboard():
    cve_entries = CVEEntry.query.all()
    return render_template('dashboard.html', cve_details_list=cve_entries)

@app.route('/library')
@login_required
def library():
    user_threads = Thread.query.filter_by(user_id=current_user.id).all()
    return render_template('library.html', threads=user_threads)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']
        user = User.query.filter_by(email=email).first()
        if user and check_password_hash(user.password, password):
            session['user_id'] = user.id
            login_user(user)
            return redirect(url_for('index'))
        else:
            return "Login Failed"
    return render_template('login.html')

@app.route('/logout', methods=['POST'])
@login_required
def logout():
    logout_user()
    session.pop('user_id', None)
    return redirect(url_for('login'))

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
        new_user = User(username=username, email=email, password=hashed_password)
        db.session.add(new_user)
        db.session.commit()
        return redirect(url_for('login'))
    return render_template('register.html')

@app.route('/save_thread', methods=['POST'])
@login_required
def save_thread():
    data = request.get_json()
    if not data or 'title' not in data or 'description' not in data:
        return jsonify({"error": "Invalid input"}), 400

    title = data['title']
    description = data['description']
    time_ago = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    new_thread = Thread(
        title=title,
        description=description,
        time_ago=time_ago,
        session_history=str(session_history),
        author=current_user
    )
    db.session.add(new_thread)
    db.session.commit()
    return jsonify({"message": "Thread saved successfully."})

def process_message_content(content):
    content = re.sub(r'###', '', content)
    content = re.sub(r'\*\*', '', content)
    content = re.sub(r'#', '', content)
    content = content.replace('*', '')
    return content.strip()

@app.route('/thread/<int:thread_id>')
@login_required
def get_thread(thread_id):
    thread = Thread.query.get_or_404(thread_id)
    if thread.author != current_user:
        return jsonify({"error": "Unauthorized access"}), 403
    
    processed_session_history = [
        {"role": msg["role"], "content": process_message_content(msg["content"])}
        for msg in eval(thread.session_history)
    ]
    return render_template('thread.html', thread={"title": thread.title, "session_history": processed_session_history}, thread_id=thread_id)


@app.route('/new_thread', methods=['POST'])
@login_required
def new_thread():
    global session_history
    session_history = []
    return jsonify({"message": "New thread started."})

@app.route('/save_cve', methods=['POST'])
@login_required
def save_cve():
    data = request.get_json()
    cve_id = data['cve_id']
    severity = data['severity']
    description = data['description']
    published_date = data['published_date']
    last_modified_date = data['last_modified_date']
    cvss_score = data['cvss_score']

    cve_entry = CVEEntry(
        cve_id=cve_id,
        severity=severity,
        description=description,
        published_date=published_date,
        last_modified_date=last_modified_date,
        cvss_score=cvss_score
    )
    db.session.add(cve_entry)
    db.session.commit()
    return jsonify({"message": "CVE entry saved successfully."})

@app.route('/ask', methods=['POST'])
@login_required
def ask():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()
    audience = data.get('audience', 'anyone')

    try:
        if "CVE-" in user_input:
            cve_id = user_input.split('/')[-1]
            result = fetch_cve_data(cve_id)
            if result and 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details, audience)
                    logging.info("Saving CVE details to DB")
                    save_cve_to_db(details)
                    return jsonify({"response": openai_response})
                else:
                    return jsonify({"error": "Failed to extract CVE details."})
            else:
                return jsonify({"error": result['error'] if result else "No CVE found."})
        else:
            search_results = perform_web_search(user_input)
            if search_results:
                summarized_context = summarize_context(search_results)
                return jsonify({"results": search_results, "summary": summarized_context})
            else:
                return jsonify({"results": [], "summary": "No relevant information found."})
    except Exception as e:
        logging.error(f"Error in /ask endpoint: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/upload', methods=['POST'])
@login_required
def upload():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if file:
        file_path = os.path.join("/tmp", file.filename)
        file.save(file_path)
        cve_ids = process_csv(file_path)
        responses = []
        for cve_id in cve_ids:
            cve_id = cve_id.upper()
            result = fetch_cve_data(cve_id)
            if 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details)
                    logging.info("Saving CVE details to DB")
                    save_cve_to_db(details)
                    responses.append({cve_id: openai_response})
                else:
                    responses.append({cve_id: "Failed to extract CVE details."})
            else:
                responses.append({cve_id: result['error']})
        return jsonify({"responses": responses})
    return jsonify({"error": "File processing failed"}), 400

@app.route('/web_search', methods=['POST'])
@login_required
def web_search():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input'].strip().upper()

    try:
        search_results = perform_web_search(user_input)
        if search_results:
            summarized_context = summarize_context(search_results)
            return jsonify({"results": search_results, "summary": summarized_context})
        else:
            return jsonify({"results": [], "summary": "No relevant information found."})
    except Exception as e:
        logging.error(f"Error in /web_search endpoint: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/follow-up', methods=['POST'])
@login_required
def follow_up():
    try:
        data = request.get_json()
        if not data or 'follow_up_question' not in data:
            return jsonify({"error": "Invalid input"}), 400

        follow_up_question = data['follow_up_question'].strip()
        logging.info(f"Processing follow-up question: {follow_up_question}")
        session_history.append({"role": "user", "content": follow_up_question})

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=session_history,
            max_tokens=100
        )
        follow_up_response = response.choices[0].message.content.strip()
        session_history.append({"role": "assistant", "content": follow_up_response})

        logging.info(f"Follow-up response: {follow_up_response}")
        return jsonify({"response": follow_up_response})
    except Exception as e:
        logging.error(f"Error in /follow-up endpoint: {str(e)}")
        return jsonify({"error": str(e)}), 500



def fetch_cve_data(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": f"Error fetching CVE data: {str(e)}"}

def extract_details(cve_data):
    if 'vulnerabilities' in cve_data and cve_data['vulnerabilities']:
        vuln_data = cve_data['vulnerabilities'][0]
        if 'cve' in vuln_data:
            vuln = vuln_data['cve']
            details = {
                'id': vuln['id'],
                'severity': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'description': vuln['descriptions'][0]['value'] if 'descriptions' in vuln and vuln['descriptions'] else 'N/A',
                'published_date': vuln['published'] if 'published' in vuln else 'N/A',
                'last_modified_date': vuln['lastModified'] if 'lastModified' in vuln else 'N/A',
                'cvss_score': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'vector_string': vuln['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'references': [{'url': ref.get('url'), 'tags': ref.get('tags', [])} for ref in vuln.get('references', [])],
                'cpe_configurations': extract_cpe_details(vuln['configurations']) if 'configurations' in vuln else []
            }
            return details
    return None

def save_cve_to_db(details):
    try:
        logging.info(f"Saving CVE: {details['id']}")
        cve_entry = CVEEntry(
            cve_id=details['id'],
            severity=details['severity'],
            description=details['description'],
            published_date=details['published_date'],
            last_modified_date=details['last_modified_date'],
            cvss_score=details['cvss_score']
        )
        db.session.add(cve_entry)
        db.session.commit()
        logging.info(f"CVE {details['id']} saved successfully")
    except Exception as e:
        logging.error(f"Error saving CVE {details['id']}: {str(e)}")

def extract_cpe_details(config_data):
    cpe_details = []
    if isinstance(config_data, dict) and 'nodes' in config_data:
        for node in config_data['nodes']:
            for cpe_match in node['cpeMatch']:
                cpe_details.append({
                    'vulnerable': cpe_match['vulnerable'],
                    'criteria': cpe_match['criteria']
                })
    elif isinstance(config_data, list):
        for config in config_data:
            if 'nodes' in config:
                for node in config['nodes']:
                    for cpe_match in node['cpeMatch']:
                        cpe_details.append({
                            'vulnerable': cpe_match['vulnerable'],
                            'criteria': cpe_match['criteria']
                        })
    return cpe_details

@app.route('/get_cve_details', methods=['POST'])
@login_required
def get_cve_details():
    data = request.get_json()
    if not data or 'cve_id' not in data:
        return jsonify({"error": "Invalid input"}), 400

    cve_id = data['cve_id'].strip().upper()
    result = fetch_cve_data(cve_id)
    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            logging.info("Saving CVE details to DB")
            save_cve_to_db(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

def get_openai_response(details, audience='anyone'):
    prompt = (
        f"\"\"\"\n"
        f"### CVE Analysis Request ###\n"
        f"Provide an in-depth analysis of the identified CVE:\n"
        f"1. **CVE Identification:**\n"
        f"   - CVE ID: {details['id']}\n"
        f"   - Severity: {details['severity']}\n"
        f"   - Description: {details['description']}\n"
        f"   - Published Date: {details['published_date']}\n"
        f"   - Last Modified Date: {details['last_modified_date']}\n"
        f"   - CVSS Score: {details['cvss_score']}\n"
        f"   - Vector String: {details['vector_string']}\n"
        f"   - References: {details['references']}\n\n"
    )

    if audience == 'beginner':
        prompt += (
            f"2. **Impact:**\n"
            f"   - Describe in simple terms how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. **Mitigation Steps:**\n"
            f"   - Provide simple steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. **Recommendations for Organizations:**\n"
            f"   - Provide basic advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    elif audience == 'advanced':
        prompt += (
            f"2. **Impact:**\n"
            f"   - Describe in detail how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. **Mitigation Steps:**\n"
            f"   - Provide detailed steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. **Recommendations for Organizations:**\n"
            f"   - Provide in-depth advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )
    else:
        prompt += (
            f"2. **Impact:**\n"
            f"   - Describe how this CVE can affect vulnerable systems. Include potential damage to systems, data, and operations.\n\n"
            f"3. **Mitigation Steps:**\n"
            f"   - Provide steps that can be taken to mitigate the risks associated with this CVE. Include recommendations on software updates, system configurations, and best practices.\n\n"
            f"4. **Recommendations for Organizations:**\n"
            f"   - Provide advice for organizations in handling this vulnerability. Include security policies, employee training, and monitoring strategies.\n\n"
        )

    # Use role-prompting
    prompt += (
        f"### Role: Cybersecurity Analyst ###\n"
        f"As a cybersecurity analyst, analyze the above CVE in the given context."
    )
    
    prompt += f'\"\"\"'
    
    session_history.append({"role": "user", "content": prompt})
    
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=100
    )
    
    message = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": message})
    return message

@app.route('/analyze_cve_data', methods=['GET'])
@login_required
def analyze_cve_data():
    try:
        cve_entries = CVEEntry.query.all()
        cve_data = [
            {
                "cve_id": entry.cve_id,
                "severity": entry.severity,
                "description": entry.description,
                "published_date": entry.published_date,
                "cvss_score": entry.cvss_score
            }
            for entry in cve_entries
        ]

        prompt = (
            "Analyze the following CVE data and provide a comprehensive insight on potential threats, vulnerable areas, "
            "and recommended actions. Highlight the most critical vulnerabilities and suggest immediate steps to mitigate risks. "
            "Provide the analysis in a structured format with sections for Threats, Vulnerable Areas, and Recommended Actions. "
            "The CVE data is as follows:\n\n"
            f"{cve_data}\n\n"
            "Format the analysis with clear sections for each part."
        )

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1000
        )

        analysis = response.choices[0].message.content.strip()
        return jsonify({"analysis": analysis})
    except Exception as e:
        logging.error(f"Error analyzing CVE data: {str(e)}")
        return jsonify({"error": str(e)}), 500


    
@app.route('/continue_conversation/<int:thread_id>', methods=['POST'])
@login_required
def continue_conversation(thread_id):
    data = request.get_json()
    new_message = data['message']

    thread = Thread.query.get_or_404(thread_id)
    g.session_history = eval(thread.session_history)
    g.session_history.append({"role": "user", "content": new_message})

    # Prepare prompt for OpenAI API with the session history
    messages = [{"role": msg["role"], "content": msg["content"]} for msg in g.session_history]

    try:
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=messages,
            max_tokens=150
        )
        bot_response = response.choices[0].message.content.strip()
        g.session_history.append({"role": "assistant", "content": bot_response})

        # Update the thread with the new session history
        thread.session_history = str(g.session_history)
        db.session.commit()

        return jsonify({"user_message": new_message, "bot_response": bot_response})
    except Exception as e:
        logging.error(f"Error continuing conversation: {str(e)}")
        return jsonify({"error": str(e)}), 500

@app.route('/continue_thread/<int:thread_id>', methods=['GET'])
@login_required
def continue_thread(thread_id):
    thread = Thread.query.get_or_404(thread_id)
    if thread.author != current_user:
        return jsonify({"error": "Unauthorized access"}), 403
    
    processed_session_history = [
        {"role": msg["role"], "content": process_message_content(msg["content"])}
        for msg in eval(thread.session_history)
    ]
    return jsonify({"thread": {"title": thread.title, "session_history": processed_session_history}})

@app.route('/add_message_to_thread/<int:thread_id>', methods=['POST'])
@login_required
def add_message_to_thread(thread_id):
    data = request.get_json()
    message_content = data['message']
    role = data['role']
    
    thread = Thread.query.get_or_404(thread_id)
    session_history = eval(thread.session_history)
    session_history.append({"role": role, "content": message_content})
    thread.session_history = str(session_history)
    db.session.commit()
    return jsonify({"message": "Message added to thread."})


def process_csv(file_path):
    df = pd.read_csv(file_path)
    cve_ids = df['cve_id'].tolist()
    return cve_ids

def perform_web_search(query):
    api_key = 'e73f29dd2ef1846a27d59d5980b5209574ce41ba489b31c841248c2f4b71fa5b'
    search_url = f"https://serpapi.com/search?q={query}&api_key={api_key}"
    try:
        response = requests.get(search_url)
        response.raise_for_status()
        data = response.json()
        return data['organic_results']
    except requests.RequestException as e:
        return {"error": f"Error accessing SERP API: {str(e)}"}

def summarize_context(results):
    if not results:
        return "No relevant information found. Please refine your query."

    content = "\n\n".join([f"Title: {res['title']}\nSnippet: {res['snippet']}" for res in results if 'snippet' in res])
    prompt = f"""
    You are Perplexity, a helpful search assistant trained by Perplexity AI. Your task is to deliver a concise and accurate response to a user's query, drawing from the given search results. Your answer must be precise, of high-quality, and written by an expert using an unbiased and journalistic tone. It is EXTREMELY IMPORTANT to directly answer the query. NEVER say "based on the search results" or start your answer with a heading or title. Get straight to the point. Your answer must be written in the same language as the query, even if language preference is different. You MUST cite the most relevant search results that answer the query. Do not mention any irrelevant results. You MUST ADHERE to the following instructions for citing search results: to cite a search result, enclose its index located above the summary with brackets at the end of the corresponding sentence, for example "Ice is less dense than water (1)." or "Paris is the capital of France (1)(2)(4)." NO SPACE between the last word and the citation, and ALWAYS use brackets. Only use this format to cite search results. NEVER include a References section at the end of your answer. If you don't know the answer or the premise is incorrect, explain why. If the search results are empty or unhelpful, answer the query as well as you can with existing knowledge. You MUST NEVER use moralization or hedging language. AVOID using the following phrases: "It is important to ..." "It is inappropriate ..." "It is subjective ..." You MUST ADHERE to the following formatting instructions: Use markdown to format paragraphs, lists, tables, and quotes whenever possible. Use headings level 2 and 3 to separate sections of your response, like "## Header", but NEVER start an answer with a heading or title of any kind (i.e. Never start with #). Use single new lines for lists and double new lines for paragraphs. Use markdown to render images given in the search results. NEVER write URLs or links.
    
    Create a summary of the following content:

    {content}

    The summary should be concise and include the main points from the content.
    """

    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=session_history,
        max_tokens=100
    )
    summary = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": summary})
    return summary

@app.route('/delete_thread/<int:thread_id>', methods=['DELETE'])
@login_required
def delete_thread(thread_id):
    thread = Thread.query.get_or_404(thread_id)
    if thread.author != current_user:
        return jsonify({"error": "Unauthorized access"}), 403

    db.session.delete(thread)
    db.session.commit()
    return jsonify({"message": "Thread deleted successfully."})

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    app.run(debug=True)
