from flask import Flask, request, jsonify, render_template
import os
import requests
from bs4 import BeautifulSoup
from openai import OpenAI

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
import pandas as pd

app = Flask(__name__)


session_history = []


app = Flask(__name__)

session_history = []

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/ask', methods=['POST'])
def ask():
    data = request.get_json()
    if not data or 'user_input' not in data:
        return jsonify({"error": "Invalid input"}), 400

    user_input = data['user_input']
    if "CVE-" in user_input.upper():
        cve_id = user_input.upper().split('/')[-1]  # Ensure only the CVE ID is passed
        result = fetch_cve_data(cve_id)
    else:
        cve_links = search_cve_google(user_input)
        if isinstance(cve_links, list) and cve_links:
            return jsonify({"cve_links": cve_links[:5]})

    if result and 'error' not in result:
        details = extract_details(result)
        if details:
            openai_response = get_openai_response(details)
            return jsonify({"response": openai_response})
        else:
            return jsonify({"error": "Failed to extract CVE details."})
    else:
        return jsonify({"error": result['error'] if result else "No CVE found."})

@app.route('/upload', methods=['POST'])
def upload():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
    if file:
        file_path = os.path.join("/tmp", file.filename)
        file.save(file_path)
        cve_ids = process_csv(file_path)
        responses = []
        for cve_id in cve_ids:
            result = fetch_cve_data(cve_id)
            if 'error' not in result:
                details = extract_details(result)
                if details:
                    openai_response = get_openai_response(details)
                    responses.append({cve_id: openai_response})
                else:
                    responses.append({cve_id: "Failed to extract CVE details."})
            else:
                responses.append({cve_id: result['error']})
        return jsonify({"responses": responses})
    return jsonify({"error": "File processing failed"}), 400

@app.route('/follow-up', methods=['POST'])
def follow_up():
    data = request.get_json()
    if not data or 'follow_up_question' not in data:
        return jsonify({"error": "Invalid input"}), 400

    follow_up_question = data['follow_up_question']
    session_history.append({"role": "user", "content": follow_up_question})
    response = client.chat.completions.create(model="gpt-4o",
    messages=session_history,
    max_tokens=500)
    follow_up_response = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": follow_up_response})
    return jsonify({"response": follow_up_response})

def fetch_cve_data(cve_id):
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        return {"error": f"Error fetching CVE data: {str(e)}"}

def search_cve_google(keyword):
    search_url = f"https://www.google.com/search?q={keyword}+site:nvd.nist.gov"
    headers = {"User-Agent": "Mozilla/5.0"}
    try:
        response = requests.get(search_url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        links = soup.find_all('a')
        cve_links = []
        for link in links:
            href = link.get('href')
            if 'nvd.nist.gov/vuln/detail' in href:
                start = href.find('https')
                end = href.find('&', start)
                cve_link = href[start:end] if end != -1 else href[start:]
                cve_links.append(cve_link)
        return cve_links
    except requests.RequestException as e:
        return {"error": f"Error searching CVE data: {str(e)}"}

def extract_details(cve_data):
    if 'vulnerabilities' in cve_data and cve_data['vulnerabilities']:
        vuln_data = cve_data['vulnerabilities'][0]
        if 'cve' in vuln_data:
            vuln = vuln_data['cve']
            details = {
                'id': vuln['id'],
                'severity': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'description': vuln['descriptions'][0]['value'] if 'descriptions' in vuln and vuln['descriptions'] else 'N/A',
                'published_date': vuln['published'] if 'published' in vuln else 'N/A',
                'last_modified_date': vuln['lastModified'] if 'lastModified' in vuln else 'N/A',
                'cvss_score': vuln['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'vector_string': vuln['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'] if 'cvssMetricV31' in vuln['metrics'] else 'N/A',
                'references': [{'url': ref.get('url'), 'tags': ref.get('tags', [])} for ref in vuln.get('references', [])],
                'cpe_configurations': extract_cpe_details(vuln['configurations']) if 'configurations' in vuln else []
            }
            return details
    return None

def extract_cpe_details(config_data):
    cpe_details = []
    if isinstance(config_data, dict) and 'nodes' in config_data:
        for node in config_data['nodes']:
            for cpe_match in node['cpeMatch']:
                cpe_details.append({
                    'vulnerable': cpe_match['vulnerable'],
                    'criteria': cpe_match['criteria']
                })
    elif isinstance(config_data, list):
        for config in config_data:
            if 'nodes' in config:
                for node in config['nodes']:
                    for cpe_match in node['cpeMatch']:
                        cpe_details.append({
                            'vulnerable': cpe_match['vulnerable'],
                            'criteria': cpe_match['criteria']
                        })
    return cpe_details

def get_openai_response(details):
    prompt = (
        f"Analisis mendalam mengenai CVE yang diidentifikasi:\n"
        f"1. **Identifikasi CVE**:\n"
        f"   - **CVE ID**: {details['id']}\n"
        f"   - **Tingkat Keparahan**: {details['severity']}\n"
        f"   - **Deskripsi**: {details['description']}\n"
        f"   - **Tanggal Publikasi**: {details['published_date']}\n"
        f"   - **Tanggal Modifikasi Terakhir**: {details['last_modified_date']}\n"
        f"   - **Skor CVSS**: {details['cvss_score']}\n"
        f"   - **String Vektor**: {details['vector_string']}\n"
        f"   - **Referensi**: {details['references']}\n\n"
        f"2. **Dampak**:\n"
        f"   - Jelaskan secara rinci bagaimana CVE ini dapat mempengaruhi sistem yang rentan. Termasuk potensi kerusakan pada sistem, data, dan operasional.\n\n"
        f"3. **Langkah-Langkah Mitigasi**:\n"
        f"   - Berikan langkah-langkah spesifik yang dapat diambil untuk mengurangi risiko yang terkait dengan CVE ini. Sertakan rekomendasi tentang pembaruan perangkat lunak, konfigurasi sistem, dan praktik terbaik.\n\n"
        f"4. **Rekomendasi untuk Organisasi**:\n"
        f"   - Saran terbaik untuk organisasi dalam menangani kerentanan ini. Termasuk kebijakan keamanan, pelatihan karyawan, dan strategi pemantauan.\n\n"
        f"5. **Contoh Kasus Nyata**:\n"
        f"   - Jika ada, sertakan contoh kasus nyata di mana CVE ini telah dieksploitasi atau diatasi. Jelaskan bagaimana situasinya ditangani dan pelajaran apa yang bisa diambil.\n"
    )
    session_history.append({"role": "user", "content": prompt})
    response = client.chat.completions.create(model="gpt-4o",
    messages=session_history,
    max_tokens=500)
    message = response.choices[0].message.content.strip()
    session_history.append({"role": "assistant", "content": message})
    return message

def process_csv(file_path):
    try:
        df = pd.read_csv(file_path)
        if 'cve_id' in df.columns:
            cve_ids = df['cve_id'].dropna().unique()
            return cve_ids
        else:
            print("CSV file must contain a 'cve_id' column.")
            return []
    except Exception as e:
        print(f"Error processing CSV file: {e}")
        return []

if __name__ == "__main__":
    app.run(debug=True)

